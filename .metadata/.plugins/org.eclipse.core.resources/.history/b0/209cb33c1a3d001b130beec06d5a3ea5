package monster;

import java.util.Vector;

import javax.swing.JFrame;

import SpriteSheet.SpriteSheet;
import character.Isaac;
import objectSize.Gap;
import objectSize.IsaacSize;
import objectSize.ViewDirect;
import objectSize.WormSize;
import structure.Rock;

public class Worm extends Monster {
	private final static String GUBUN = "Worm : ";

	public Worm(JFrame app, Isaac isaac, Vector<Rock> rock, String url, int imgWidth, int imgHeight) {
		super(app, isaac, rock, url, imgWidth, imgHeight);
		new Thread(new Runnable() {
		@Override
		public void run() {
			while(!isDead()) {
				moveDirectCheck();
				collisionRock();
				moveUp();
				moveDown();
				moveRight();
				moveLeft();
				moveMotion();
				getMonster().drawObject(getXChar(), getYChar());
				try {
					Thread.sleep(30);
				} catch (InterruptedException e) {
					// TODO Auto-generated catch block
					e.printStackTrace();
				}
				if(isAttacking() == false) {
					attack();
				}
			}
		}
	}).start();
	}
	public void init() {
		setMonster(new SpriteSheet(getUrl(), "monster", 0, 0, getImgWidth(), getImgHeight())); 
	}
	public void setting() {
		setViewDirect(ViewDirect.RIGHT);
		setXChar(180);
		setYChar(130);	
		setLife(10);
		setAttackDamge(1);
	}
	public void batch() {
		getMonster().drawObject(getXChar(), getYChar());
		getApp().add(getMonster(), 0);
	}
	@Override
	public void attack() {
		new Thread(new Runnable() {
			@Override
			public void run() {
				int xDistance, yDistance;
				switch (getViewDirect()) {
					case ViewDirect.DOWN:
						setAttacking(true);
						xDistance = (getIsaac().getXChar()) - (getXChar());
						yDistance = (getYChar() + WormSize.HEIGHT) - (getIsaac().getYChar() + 15);
						xDistance = xDistance < 0 ? xDistance * -1 : xDistance;
						yDistance = yDistance < 0 ? yDistance * -1 : yDistance;
						if(xDistance < 25 && yDistance < 10) {
							getMonster().setXPos((WormSize.WIDTH * (ViewDirect.DOWN - 1)) + (Gap.COLUMNGAP * (ViewDirect.DOWN - 1)));
							getMonster().setYPos(WormSize.HEIGHT * (ViewDirect.DOWN - 1) + Gap.ROWGAP * (ViewDirect.DOWN - 1));
							getMonster().drawObject(getXChar(), getYChar());
							try {
								Thread.sleep(200);
							} catch (InterruptedException e) {
								e.printStackTrace();
							}
							getMonster().setXPos(0);
							getMonster().setYPos(WormSize.HEIGHT * (ViewDirect.DOWN - 1) + Gap.ROWGAP * (ViewDirect.DOWN - 1));
							getMonster().drawObject(getXChar(), getYChar());
							getIsaac().setLife(getIsaac().getLife() - 1);
							try {
								Thread.sleep(2000);
							} catch (InterruptedException e) {
								e.printStackTrace();
							}
						}
						break;	
					case ViewDirect.LEFT:
						setAttacking(true);
						xDistance = (getIsaac().getXChar() + IsaacSize.HEADWIDTH - 10) - (getXChar());
						yDistance = getIsaac().getYChar() - getYChar();
						xDistance = xDistance < 0 ? xDistance * -1 : xDistance;
						yDistance = yDistance < 0 ? yDistance * -1 : yDistance;
						if(xDistance < 10 && yDistance < 30) {
							getMonster().setXPos((WormSize.WIDTH * (ViewDirect.LEFT - 1)) + (Gap.COLUMNGAP * (ViewDirect.LEFT - 1)));
							getMonster().setYPos(WormSize.HEIGHT * (ViewDirect.LEFT - 1) + Gap.ROWGAP * (ViewDirect.LEFT - 1));
							getMonster().drawObject(getXChar(), getYChar());
							try {
								Thread.sleep(200);
							} catch (InterruptedException e) {
								e.printStackTrace();
							}
							getMonster().setXPos(0);
							getMonster().setYPos(WormSize.HEIGHT * (ViewDirect.LEFT - 1) + Gap.ROWGAP * (ViewDirect.LEFT - 1));
							getMonster().drawObject(getXChar(), getYChar());
							getIsaac().setLife(getIsaac().getLife() - 1);
							try {
								Thread.sleep(2000);
							} catch (InterruptedException e) {
								e.printStackTrace();
							}
						}
						break;
					case ViewDirect.UP:
						setAttacking(true);
						xDistance = (getIsaac().getXChar()) - (getXChar());
						yDistance = getYChar() - (getIsaac().getYChar() + IsaacSize.HEADHEIGHT);
						xDistance = xDistance < 0 ? xDistance * -1 : xDistance;
						yDistance = yDistance < 0 ? yDistance * -1 : yDistance;
						if(xDistance < 25 && yDistance < 10) {
							getMonster().setXPos((WormSize.WIDTH * 3) + (Gap.COLUMNGAP * 3));
							getMonster().setYPos(WormSize.HEIGHT * 4 + Gap.ROWGAP * 4);
							getMonster().drawObject(getXChar(), getYChar());
							try {
								Thread.sleep(200);
							} catch (InterruptedException e) {
								e.printStackTrace();
							}
							getMonster().setXPos(0);
							getMonster().setYPos(WormSize.HEIGHT * 2 + Gap.ROWGAP * 2);
							getMonster().drawObject(getXChar(), getYChar());
							getIsaac().setLife(getIsaac().getLife() - 1);
							try {
								Thread.sleep(2000);
							} catch (InterruptedException e) {
								e.printStackTrace();
							}
						}
						break;
					
					
					
					case ViewDirect.RIGHT:
						setAttacking(true);
						xDistance = (getIsaac().getXChar() + 10) - (getXChar() + WormSize.WIDTH);
						yDistance = getIsaac().getYChar() - getYChar();
						xDistance = xDistance < 0 ? xDistance * -1 : xDistance;
						yDistance = yDistance < 0 ? yDistance * -1 : yDistance;
						if(xDistance < 10 && yDistance < 30) {
							getMonster().setXPos((WormSize.WIDTH * 1) + (Gap.COLUMNGAP * 1));
							getMonster().setYPos(WormSize.HEIGHT * 4 + Gap.ROWGAP * 4);
							getMonster().drawObject(getXChar(), getYChar());
							try {
								Thread.sleep(200);
							} catch (InterruptedException e) {
								e.printStackTrace();
							}
							getMonster().setXPos(0);
							getMonster().setYPos(WormSize.HEIGHT * 0 + Gap.ROWGAP * 0);
							getMonster().drawObject(getXChar(), getYChar());
							getIsaac().setLife(getIsaac().getLife() - 1);
							try {
								Thread.sleep(2000);
							} catch (InterruptedException e) {
								e.printStackTrace();
							}
						}
						break;
				}
				setAttacking(false);
			} 
			
		}).start();
		
	}
}
