package character;



import javax.swing.JFrame;
import javax.swing.JLabel;

import SpriteSheet.SpriteSheet;
import lombok.Data;
import objectSize.Gap;
import objectSize.IsaacSize;

@Data

public class Isaac extends Character{

	private final static String TAG = "Isaac : ";
	
	private Isaac isaac = this;
	private SpriteSheet ssHead, ssBody;
	

	public Isaac(JFrame app) {
		System.out.println(TAG + "make Isaac");
		setApp(app);	// jframe
		init();
		setting();
		ssHead.drawObject(getXChar(), getYChar());
		ssBody.drawObject(getXChar() + 4, getYChar() + 20);
		getApp().add(ssHead);
		getApp().add(ssBody);

	}
	public void init() {
		ssHead = new SpriteSheet("isaac/isaac.png", "IsaacssHead", 0, 0, IsaacSize.HEADWIDTH, IsaacSize.HEADHEIGHT);
		ssBody = new SpriteSheet("isaac/isaac.png", "IsaacBody", 0, (IsaacSize.HEADHEIGHT + Gap.ROWGAP), IsaacSize.BODYWIDTH, IsaacSize.BODYHEIGHT);
		
	}
	public void setting() {
		// 아이작 초반 위치 설정
		setXChar(480);
		setYChar(300);
		setAttackDamge(1);
	}
	public void closeEye(int viewDirect) {
		switch (viewDirect) {
		case 1:	// 보는 방향 아래
			ssHead.setXPos(IsaacSize.HEADWIDTH + Gap.COLUMNGAP);
			break;
		case 2:	// 보는 방향 왼쪽
			ssHead.setXPos(IsaacSize.HEADWIDTH * 7 + Gap.COLUMNGAP * 7);
			break;
		case 3:	// 보는 방향 위
			ssHead.setXPos(IsaacSize.HEADWIDTH * 5 + Gap.COLUMNGAP * 5);
			break;
		case 4:	// 보는 방향 오른쪽
			ssHead.setXPos(IsaacSize.HEADWIDTH * 3 + Gap.COLUMNGAP * 3);
			break;
		}
	}
	public void openEye(int viewDirect) {
		switch (viewDirect) {
		case 1:	// 보는 방향 아래
			ssHead.setXPos(0);
			break;
		case 2:	// 보는 방향 왼쪽
			ssHead.setXPos(IsaacSize.HEADWIDTH * 6 + Gap.COLUMNGAP * 6);
			break;
		case 3:	// 보는 방향 위
			ssHead.setXPos(IsaacSize.HEADWIDTH * 4 + Gap.COLUMNGAP * 4);
			break;
		case 4:	// 보는 방향 오른쪽
			ssHead.setXPos(IsaacSize.HEADWIDTH * 2 + Gap.COLUMNGAP * 2);
			break;
		}
	}
	
	@Override
	public void moveRight() {
		new Thread(new Runnable() {
			@Override
			public void run() {
				if(isRight() == false) {
					System.out.println(TAG + "오른쪽으로 움직임");
					setRight(true);	// 오른쪽 방향키 누름
					ssHead.setXPos(IsaacSize.HEADWIDTH * 2 + Gap.COLUMNGAP * 2);	// 머리 이미지 x좌표
					ssBody.setYPos(IsaacSize.HEADHEIGHT + IsaacSize.BODYHEIGHT + Gap.ROWGAP * 2);	// 몸 이미지 y좌표
					int motion = 0;
					setViewDirect(4);	// 머리방향 right
					while(isRight()) {
						if(getXChar() + IsaacSize.BODYWIDTH > 820) {
							setRight(false);
							refreshDirect();
							break;
						}
						if(motion == 10)
							motion = 0;
						setXChar(getXChar() + 3);
						ssBody.setXPos((IsaacSize.BODYWIDTH * motion) + (Gap.COLUMNGAP * motion));
						if(getViewDirect() == 4) {
							ssHead.setXPos(IsaacSize.HEADWIDTH * 2 + Gap.COLUMNGAP * 2);	// 머리 이미지 x좌표
							ssBody.setYPos(IsaacSize.HEADHEIGHT + IsaacSize.BODYHEIGHT + Gap.ROWGAP * 2);	// 몸 이미지 y좌표
							ssHead.drawObject(getXChar(), getYChar());
							ssBody.drawObject(getXChar() + 4, getYChar() + 20);
							motion += 1;
						}
						try {
							Thread.sleep(30);
						} catch (Exception e) {
							e.printStackTrace();
						}
					}
					ssBody.setXPos(0);
					ssBody.drawObject(getXChar() + 4, getYChar() + 20);
				}
			}
		}).start();
	}
	@Override
	public void moveLeft() {
		new Thread(new Runnable() {
			@Override
			public void run() {
				if(isLeft() == false) {
					System.out.println(TAG + "왼쪽으로 움직임");
					int motion = 9;
					setLeft(true);	// 오른쪽 방향키 누름
					ssHead.setXPos(IsaacSize.HEADWIDTH * 6 + Gap.COLUMNGAP * 6);
					ssBody.setYPos(IsaacSize.HEADHEIGHT + IsaacSize.BODYHEIGHT * 2 + Gap.ROWGAP * 3);
					setViewDirect(2);	// 머리방향 left
					while(isLeft()) {
						if(getXChar() < 130) {
							setLeft(false);	
							refreshDirect();
							break;
						}
						if(motion > 9)
							motion = 0;
						setXChar(getXChar() - 3);
						ssBody.setXPos((IsaacSize.BODYWIDTH * motion) + (Gap.COLUMNGAP * motion));
						if(getViewDirect() == 2) {
							ssHead.setXPos(IsaacSize.HEADWIDTH * 6 + Gap.COLUMNGAP * 6);
							ssBody.setYPos(73);
							ssHead.drawObject(getXChar(), getYChar());
							ssBody.drawObject(getXChar() + 4, getYChar() + 20);
							motion += 1;
						}
						try {
							Thread.sleep(30);
						} catch (Exception e) {
							e.printStackTrace();
						}
					}
					ssBody.setXPos(0);
					ssBody.drawObject(getXChar() + 4, getYChar() + 20);
				}
			}
		}).start();
	}
	@Override
	public void moveDown() {
		new Thread(new Runnable() {
			@Override
			public void run() {
				if(isDown() == false) {
					System.out.println(TAG + "아래쪽으로 움직임");
					int motion = 0;
					setDown(true);	// 오른쪽 방향키 누름
					ssHead.setXPos(0);
					ssBody.setYPos(IsaacSize.HEADWIDTH + Gap.COLUMNGAP);
					setViewDirect(1);	// 머리방향 left
					while(isDown()) {

						if(getYChar() > 455) {
							setDown(false);
							refreshDirect();
							break;
						}
						if(motion > 9)
							motion = 0;
						setYChar(getYChar() + 3);
						ssBody.setXPos((IsaacSize.BODYWIDTH * motion) + (Gap.COLUMNGAP * motion));
						if(getViewDirect() == 1) {
							ssHead.setXPos(0);
							ssBody.setYPos(IsaacSize.HEADWIDTH + Gap.COLUMNGAP);
							ssHead.drawObject(getXChar(), getYChar());
							ssBody.drawObject(getXChar() + 4, getYChar() + 20);
							motion += 1;
						}
						try {
							Thread.sleep(30);
						} catch (Exception e) {
							e.printStackTrace();
						}
					}
					ssBody.setXPos(0);
					ssBody.drawObject(getXChar() + 4, getYChar() + 20);
				}
			}
		}).start();
	}
	@Override
	public void moveUp() {
		new Thread(new Runnable() {
			@Override
			public void run() {
				if(isUp() == false) {
					System.out.println(TAG + "위쪽으로 움직임");
					int motion = 0;
					setUp(true);	// 오른쪽 방향키 누름
					ssHead.setXPos(IsaacSize.HEADWIDTH * 4 + Gap.COLUMNGAP * 4);
					ssBody.setYPos(IsaacSize.HEADHEIGHT + Gap.ROWGAP);
					setViewDirect(3);	// 머리방향 left
					while(isUp()) {
						if(getYChar() < 100) {
							setUp(false);
							refreshDirect();
							break;
						}
						if(motion > 9)
							motion = 0;
						setYChar(getYChar() - 3);
						ssBody.setXPos((IsaacSize.BODYWIDTH * motion) + (Gap.COLUMNGAP * motion));
						if(getViewDirect() == 3) {
							ssHead.setXPos(IsaacSize.HEADWIDTH * 4 + Gap.COLUMNGAP * 4);
							ssBody.setYPos(31);
							ssHead.drawObject(getXChar(), getYChar());
							ssBody.drawObject(getXChar() + 4, getYChar() + 20);
							motion += 1;
						}
						try {
							Thread.sleep(30);
						} catch (Exception e) {
							e.printStackTrace();
						}
					}
					ssBody.setXPos(0);
					ssBody.drawObject(getXChar() + 4, getYChar() + 20);
				}
			}
		}).start();
	}
	public void refreshDirect() {
		if(isaac.isDown()) {
			isaac.setViewDirect(1);
		}
		if(isaac.isLeft()) {
			isaac.setViewDirect(2);
		}
		if(isaac.isUp()) {
			isaac.setViewDirect(3);
		}
		if(isaac.isRight()) {
			isaac.setViewDirect(4);
		}

	}
}
// 2초마다 눈깜박임
//new Thread(new Runnable() {
//	@Override
//	public void run() {
//		int xCurrent;
//		int xChange;
//		while(true) {
//			try {
//				Thread.sleep(2000);
//			} catch (Exception e) {
//				e.printStackTrace();
//			}
//			closeEye(getViewDirect());
//			head.drawObject(getXChar(), getYChar());
//			try {
//				Thread.sleep(500);
//			} catch (Exception e) {
//				e.printStackTrace();
//			}
//			openEye(getViewDirect());
//			ssHead.drawObject(getXChar(), getYChar());
//			
//		}
//	}
//}).start();
