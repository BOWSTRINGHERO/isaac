package bullet;

import java.util.Vector;

import javax.swing.JFrame;
import SpriteSheet.SpriteSheet;
import lombok.Data;

@Data

public class BulletControl {
	private final static String TAG = "BulletControl : ";
	
	private JFrame app;
	private Vector<Bullet> bullets = new Vector<Bullet>();
	private boolean delayBullet = false;
	
	public BulletControl(JFrame app) {
		this.app = app;
		// 1초에 한번씩 쏘도록 함.
		new Thread(new Runnable() {
			@Override
			public void run() {

			
			}
//				while(true) {
//					if(delayBullet) {
//						try {
//							Thread.sleep(1000);
//						} catch (InterruptedException e) {
//							e.printStackTrace();
//						}
//						delayBullet = false;
//					}
//				}
		}).start();
		
		// 불릿 움직이는 스레드
		new Thread(new Runnable() {
			@Override
			public void run() {
				while(true) {
					if(bullets.size() != 0) {
						for (int i = 0; i < bullets.size(); i++) {
							if(bullets.get(i).getDirect() == 1) {	// 보는 방향이 아래
								bullets.get(i).setYBullet(bullets.get(i).getYBullet() + 1);
							} else if(bullets.get(i).getDirect() == 2) {	// 보는 방향이 왼쪽
								bullets.get(i).setXBullet(bullets.get(i).getXBullet() - 1);
							} else if(bullets.get(i).getDirect() == 3) {	// 보는 방향이 위쪽
								bullets.get(i).setYBullet(bullets.get(i).getYBullet() - 1);
							} else {	// 보는 방향 오른쪽
								bullets.get(i).setXBullet(bullets.get(i).getXBullet() + 1);
							}
							bullets.get(i).getSsBullet().drawObject(bullets.get(i).getXBullet(), bullets.get(i).getYBullet());
						}
						try {
							Thread.sleep(5);
						} catch (InterruptedException e) {
							// TODO Auto-generated catch block
							e.printStackTrace();
						}
					}
				}
			}
		}).start();
	}
	
	public void addBullet(String gubun, double attackDamage, int direct, int xBullet, int yBullet) {
		if(!delayBullet) {
			System.out.println(delayBullet);
			if(direct == 1) {	// 보는 방향이 아래
				bullets.add(new Bullet(gubun, attackDamage, direct, xBullet + 6, yBullet + 18));
			} else if(direct == 2) {	// 보는 방향이 왼쪽
				bullets.add(new Bullet(gubun, attackDamage, direct, xBullet - 13, yBullet + 8));
			} else if(direct == 3) {	// 보는 방향이 위
				bullets.add(new Bullet(gubun, attackDamage, direct, xBullet + 6, yBullet - 14));
			} else {
				bullets.add(new Bullet(gubun, attackDamage, direct, xBullet + 26, yBullet + 8));
			}
			drawBullet();
			try {
				Thread.sleep(1000);
			} catch (InterruptedException e) {
				e.printStackTrace();
			}
			delayBullet = true;
		}
	}
	public void drawBullet() {
		if(bullets.size() != 0) {
			for (int i = 0; i < bullets.size(); i++) {
				app.add(bullets.get(i).getSsBullet(),0);
				bullets.get(i).getSsBullet().drawObject(bullets.get(i).getXBullet(), bullets.get(i).getYBullet());
			}
		}
	}
	
	public void removeBullet() {
		
	}
	
	public void removingMotion() {
		
	}
	
	public void wallCollison() {
		
	}
	
	
	// 구현되야 하는 것들
	// 몹 충돌
	// 구조물 충돌
}
